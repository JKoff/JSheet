<!DOCTYPE html>
<html>
<head>
    <title>JSheet</title>
    <link rel="stylesheet" href="app.css">
</head>
<body>

<div id="grid"></div>

<script src="eval.js"></script>
<script src="grid.js"></script>
<script>
    let state = JSON.parse(localStorage.getItem('state')) || { display: {}, code: {}, results: {}, inputs: {}, parent: {} };
    for (const key in state.results) {
        state.results[key] = new JArray(state.results[key].shape, state.results[key].data);
    }

    const parseIdRE = /R(?<row>[\-0-9]+)C(?<col>[\-0-9]+)/;
    function parseId(id) {
        let res;
        if ((res = parseIdRE.exec(id)) !== null) {
            return { row: parseInt(res.groups.row, 10), col: parseInt(res.groups.col, 10) };
        }
        return null;
    }

    const computeState = { dirty: new Set() };

    function downstreamCells(id) {
        return Object.keys(state.inputs).filter(k => state.inputs[k].includes(id));

    }

    function refreshEffects() {
        const seen = new Set();
        const stack = Array.from(computeState.dirty);
        while (stack.length > 0) {
            const id = stack.pop();
            if (seen.has(id)) continue;
            seen.add(id);

            if (state.code[id]) {
                setCellCode(id, state.code[id]);
                unrollCodeCell(id);
            } else {
                setCellDisplay(id, state.display[id], state.parent[id]);
            }

            stack.push(...downstreamCells(id));
        }
        computeState.dirty.clear();
    }

    function setCellCode(id, code) {
        state.inputs[id] = [];
        state.code[id] = code;
        delete state.results[id];

        try {
            state.results[id] = runJFragment(code, symbol => {
                let split;
                if ((split = symbol.split(':')).length === 2) {
                    const start = parseId(split[0]), end = parseId(split[1]);
                    if (start === null || end === null) {
                        throw new Error('Not a valid symbol: ', symbol);
                    }
                    let data = [];
                    for (let i = start.row; i <= end.row; i++) {
                        for (let j = start.col; j <= end.col; j++) {
                            const iid = `R${i}C${j}`;
                            if (!state.results[iid]) continue;

                            const val = state.results[iid].only();
                            if (!state.inputs[id].includes(iid)) {
                                state.inputs[id].push(iid);
                            }
                            data.push(val);
                        }
                    }
                    return new JArray([end.row - start.row + 1, end.col - start.col + 1], data);
                } else if (split.length === 1) {
                    const val = state.results[symbol] || parseInt(state.display[symbol], 10) || null;
                    if (val !== null && !state.inputs[id].includes(symbol)) {
                        state.inputs[id].push(symbol);
                    }
                    return val;
                } else {
                    return null;
                }
            });
        } catch (e) {
            console.log('Error running J fragment:', e.message)
            state.results[id] = new JArray([], [code]);
        }

        requestRefresh(id);
        computeState.dirty.add(id);
    }

    function setCellDisplay(id, display, parentId) {
        state.parent[id] = parentId;
        state.display[id] = display;

        requestRefresh(id);
        computeState.dirty.add(id);
    }

    function unrollCodeCell(id) {
        const result = state.results[id];
        if (result === undefined) {
            return;
        }
        const cell = document.getElementById(id);
        const startRow = parseInt(cell.dataset.row, 10), startCol = parseInt(cell.dataset.col, 10);
        if (result.shape.length === 0) {
            const id = `R${startRow}C${startCol}`;
            if (`${result.data[0]}` !== state.code[cell.id]) {
                setCellDisplay(id, result.data[0], null);
            } else {
                setCellDisplay(id, null, null);
            }
        } else {
            const id = `R${startRow}C${startCol}`;
            setCellDisplay(id, null, null);
            let row = startRow, col = startCol + 1;
            for (let i = 0; i < (result.shape[0] || 1); i++) {
                for (let j = 0; j < (result.shape[1] || 1); j++) {
                    let iid = `R${row}C${col}`;
                    while (state.code[iid] && state.parent[iid] !== id) {
                        col++;
                        iid = `R${row}C${col}`;
                    }
                    setCellDisplay(iid, `${result.data[i * result.shape[0] + j]}`, cell.id);
                    col++;
                }
                row++;
                col = startCol + 1;
            }
        }
    }

    function commitCell(cell) {
        if (!cell) {
            return;
        }
        if (cell.value === '') {
            deleteCell(cell);
            return;
        }

        setCellCode(cell.id, cell.value);
        const result = state.results[cell.id];

        unrollCodeCell(cell.id);

        refreshEffects();
        localStorage.setItem('state', JSON.stringify(state));
    }

    function deleteCell(cell) {
        const id = cell.id;
        delete state.code[id];
        delete state.results[id];
        delete state.inputs[id];
        delete state.parent[id];
        delete state.display[id];
        requestRefresh(id);
        computeState.dirty.add(id);
        localStorage.setItem('state', JSON.stringify(state));
    }

    document.querySelector('#grid').replaceWith(renderGrid(state));
    bindGridListeners(document.body, commitCell, deleteCell);
</script>
</body>
</html>