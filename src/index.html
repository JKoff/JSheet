<!DOCTYPE html>
<html>
<head>
    <title>JSheet</title>
    <link rel="stylesheet" href="app.css">
</head>
<body>

<div id="grid"></div>

<script src="eval.js"></script>
<script src="grid.js"></script>
<script>
    let state = JSON.parse(localStorage.getItem('jsheet')) || { cells: {} };
    if (state.cells === undefined) state.cells = {};
    for (const key of Object.keys(state.cells)) {
        const { code, display, result, inputs, parent } = state.cells[key];
        state.cells[key] = {
            code, display, inputs, parent,
            result: result ? new JArray(result.shape, result.data) : undefined
        };
    }

    const parseIdRE = /R(?<row>[\-0-9]+)C(?<col>[\-0-9]+)/;
    function parseId(id) {
        let res;
        if ((res = parseIdRE.exec(id)) !== null) {
            return { row: parseInt(res.groups.row, 10), col: parseInt(res.groups.col, 10) };
        }
        return null;
    }

    const computeState = { dirty: new Set() };

    function downstreamCells(id) {
        return Object.keys(state.cells).filter(k => (state.cells[k].inputs || []).includes(id));
    }

    function refreshEffects() {
        const seen = new Set();
        const stack = Array.from(computeState.dirty);
        while (stack.length > 0) {
            const id = stack.pop();
            if (seen.has(id)) continue;
            seen.add(id);

            const st = state.cells[id];
            if (st.code) {
                setCellCode(id, st.code);
                unrollCodeCell(id);
            } else {
                setCellDisplay(id, st.display, st.result, st.parent);
            }

            stack.push(...downstreamCells(id));
        }
        computeState.dirty.clear();
    }

    function setCellCode(id, code) {
        const st = state.cells[id] = { code, inputs: [] };

        try {
            st.result = runJFragment(code, symbol => {
                let split;
                if ((split = symbol.split(':')).length === 2) {
                    const start = parseId(split[0]), end = parseId(split[1]);
                    if (start === null || end === null) {
                        throw new Error('Not a valid symbol: ', symbol);
                    }
                    let data = [];
                    for (let i = start.row; i <= end.row; i++) {
                        for (let j = start.col; j <= end.col; j++) {
                            const iid = `R${i}C${j}`;
                            const ist = state.cells[iid];
                            if (!ist || !ist.result) continue;

                            if (!st.inputs.includes(iid)) {
                                st.inputs.push(iid);
                            }
                            data.push(ist.result.only());
                        }
                    }
                    return new JArray([end.row - start.row + 1, end.col - start.col + 1], data);
                } else if (split.length === 1) {
                    const ist = state.cells[symbol];
                    const val = ist.result || parseInt(ist.display, 10) || null;
                    if (val !== null && !st.inputs.includes(symbol)) {
                        st.inputs.push(symbol);
                    }
                    return val;
                } else {
                    return null;
                }
            });
        } catch (e) {
            console.log('Error running J fragment:', e.message)
            st.result = new JArray([], [code]);
        }

        requestRefresh(id);
        computeState.dirty.add(id);
    }

    function setCellDisplay(id, display, result, parentId) {
        state.cells[id] = { display, result, parent: parentId };

        requestRefresh(id);
        computeState.dirty.add(id);
    }

    function unrollCodeCell(id) {
        const { result, code } = state.cells[id];
        if (result === undefined) {
            return;
        }
        if (result.shape.length === 0 && `${result.data[0]}` === code) {
            return;
        }
        let { row, col } = parseId(id);
        for (let i = 0; i < result.data.length; i++) {
            const dimSizes = result.shape.reduce((acc, val) => acc.concat(val * acc[acc.length - 1] || 1), []);
            const coords = result.shape.reduce(([coords, idx], dimSize) => [coords.concat(idx % dimSize), Math.floor(idx / dimSize)], [[], i])[0];
            setCellDisplay(`R${row + (coords[1] || 0)}C${col + (coords[0] || 0) + 1}`, `${result.data[i]}`, new JArray([], [result.data[i]]), id);
        }
    }

    function commitCell(cell) {
        if (!cell) {
            return;
        }
        if (cell.value === '') {
            deleteCell(cell);
            return;
        }

        setCellCode(cell.id, cell.value);
        unrollCodeCell(cell.id);

        refreshEffects();
        localStorage.setItem('jsheet', JSON.stringify(state));
    }

    function deleteCell(cell) {
        const id = cell.id;
        delete state.cells[id];
        requestRefresh(id);
        computeState.dirty.add(id);
        localStorage.setItem('jsheet', JSON.stringify(state));
    }

    document.querySelector('#grid').replaceWith(renderGrid(state));
    bindGridListeners(document.body, commitCell, deleteCell);
</script>
</body>
</html>